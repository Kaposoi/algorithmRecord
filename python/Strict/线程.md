# 线程

线程是程序执行的一条分支， 是程序执行流的最小单元， 是**被系统独立调度和分派的基本单位**， 它自己不拥有系统资源， 只拥有很少的在运行中不可或缺的资源， 但是它可以和同属一个进程的其他线程共享进程所拥有的全部资源



## 主线程

当程序启动时， 主线程就被创建

- 主线程产生其他线程
- 通常主线程必须最后完成执行， 执行退出等操作等
- 主线程会等待所有子线程结束后才结束



## 子线程

子线程由主线程创建， 创建后子线程和主线程一起执行



## threading模块

### threading.Thread(target=函数名)

>创建子线程对象
>
>参数
>
>target=函数名(target用于指定分支)



### threading.start()

>启动子线程
>
>由线程对象调用



## 查看线程数量

### threading.enumerate()

>获取当前所有活跃的线程对象列表， 使用len()对列表求长度可以看到当前活跃的线程的个数
>
>注: 当判断是否子线程都结束了， 只需要用循环判断len是否为1



## 查看线程名称

### threading.current_thread()

>获取当前的线程对象， 对象中含有名称
>
>(名称是python自己指定的)



## 线程的参数和顺序

### 参数的传递

这个参数是要执行函数的参数

>参数的传递主要有三种方式
>
>.1) 使用元组传递
>
>(target=, args=(..1, ..2, ...))
>
>```
>thread_recvmsg = threading.Thread(target=recv_msg, args=(udp_socket, ))
>```
>
>.2) 使用字典传递
>
>(target=, kwargs={"a": 10, ...})
>
>.3) 同时使用元组和字典



### 执行顺序

>线程的执行顺序是无序的

​	

## 守护线程

如果将子线程设置为守护线程， 那么子线程会在主线程结束时自动退出， 否则当主线程退出时， 子线程仍然会继续执行



### 设置守护

>threading.setDaemon(True)



## 并行和并发

### 多任务原理

>多任务的执行原理并非是在同时执行多个任务， 只是任务1执行一段时间后， 切换到任务2执行， 一段时间后再切换...
>
>由于cpu执行速度很快， 因此看着就像是同时执行一般



### 并发

>任务数多于cpu核量， 通过调度任务， 切换任务执行， 来实现"一起"执行的效果



### 并行

>任务数少于cpu核数， 任务是真正的一起执行



## 自定义线程类

继承threading.Thread可以实现自定义线程类

>1. 重写run方法
>2. 调用start方法启动线程(start方法中也会调用run方法)
>
> 
>
>__init__方法中， 子类先调用父类的init方法， 然后再初始化



## 多线程共享全局变量

多线程之间可以共享全局变量

多线程同时访问同一个资源， 可能会出现资源竞争的问题

>优先让某个线程先执行
>
>线程对象.join()
>
>缺点: 把多线程变成了单线程



## 同步与异步

同步执行任务时， 只有当前一个任务已经执行完成， 才能去执行后一个任务

而异步执行任务时， 即执行任务没有先后顺序， 可以多个任务同时执行(也许相当于并行)



### 线程锁机制

当线程获取资源后， 立刻进行锁定， 资源使用完毕后再解锁， 有效保证了同一时间内只有一个线程在使用资源, 线程锁的目的是实现线程同步





### 互斥锁

threading模块中定义了Lock类， 可以方便的进行锁定

>mutex = threading.Lock()
>
>mutex.acquire() 锁定
>
>mutex.release() 释放

在要执行的函数中使用， 可以锁定接下来的变量

### 死锁

如果多线程任务中， 多个线程同时占用一部分资源且在等待对方的资源， 就会造成死锁

